#!/bin/bash
# AWStats Updater 2.3 (build 20170730)
# https://github.com/PhrozenByte/awstats-update
#
# Copyright (C) 2011-2017  Daniel Rudolf <www.daniel-rudolf.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License only.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# See <http://www.gnu.org/licenses/> to receive a full-text-copy of
# the GNU General Public License.

APP_NAME="$(basename "$0")"
EXIT_CODE=0

BUILD="20170730"
VERSION="2.3"

# usage
function showUsage() {
    echo "Usage:"
    echo "  $APP_NAME [OPTION]..."
    echo "  $APP_NAME [OPTION]... CONFIG..."
    echo "      CONFIG can either be:"
    echo "          - a absolute path to a config file"
    echo "          - a relative path to a config file, starting from /etc/awstats/"
    echo "          - a config spec in the form [ HOST_TYPE \"/\" ] HOST"
}

# include debian config
AWSTATS_NICE=""
AWSTATS_LANG="en"
AWSTATS_FORMAT="plain"
AWSTATS_DATA_DIR=""
AWSTATS_WWW_DIR=""
if [ -r "/etc/default/awstats" ]; then
    . "/etc/default/awstats"
fi

# use getopt to parse parameters
if ! OPTIONS="$(
    getopt -n "$APP_NAME" -o aovqh \
    -l "no-update" -l "update" -l "no-rebuild" -l "rebuild" -l "rebuild-all" -l "overwrite" \
    -l "no-config::" -l "format:" -l "lang:" -l "data-dir:" -l "www-dir:" -l "standalone:" \
    -l "verbose" -l "quiet"  -l "help" -l "version" -- "$@"
)"; then
    showUsage
    exit 1
fi
eval set -- "$OPTIONS"

# parse options
UPDATE="yes"
REBUILD="current"
OVERWRITE="no"
NO_CONFIG=""
CONFIG_DIR=""
STANDALONE=""
VERBOSE=1

while true; do
    case "$1" in
        "--update")
            UPDATE="yes"
            shift
            ;;

        "--no-update")
            UPDATE="no"
            shift
            ;;

        "--rebuild")
            REBUILD="current"
            shift
            ;;

        "--no-rebuild")
            REBUILD="no"
            shift
            ;;

        "-a"|"--rebuild-all")
            REBUILD="all"
            shift
            ;;

        "-o"|"--overwrite")
            OVERWRITE="yes"
            shift
            ;;

        "--no-config")
            if [ -n "$2" ]; then
                NO_CONFIG="$2"
            else
                NO_CONFIG="awstats.conf"
            fi
            shift 2
            ;;

        "--format")
            AWSTATS_FORMAT=""
            IFS=','; for ADD_FORMAT in $2; do
                if [ "$ADD_FORMAT" == "plain" ] || [ "$ADD_FORMAT" == "gzip" ]; then
                    [ -z "$AWSTATS_FORMAT" ] && AWSTATS_FORMAT="$ADD_FORMAT" || AWSTATS_FORMAT+=",$ADD_FORMAT"
                else
                    echo "$APP_NAME: Invalid argument '$2' for '--format'" >&2
                    exit 1
                fi
            done

            shift 2
            ;;

        "--lang")
            AWSTATS_LANG="$2"
            shift 2
            ;;

        "--data-dir")
            AWSTATS_DATA_DIR="$2"
            shift 2
            ;;

        "--www-dir")
            AWSTATS_WWW_DIR="$2"
            shift 2
            ;;

        "--standalone")
            STANDALONE="$2"
            shift 2
            ;;

        "-v"|"--verbose")
            ((VERBOSE++))
            shift
            ;;

        "-q"|"--quiet")
            ((VERBOSE--))
            shift
            ;;

        "-h"|"--help")
            showUsage
            echo
            echo "Update AWStats database and/or generate static HTML pages, either of the"
            echo "specified or all known hosts. By default, $APP_NAME updates the database"
            echo "(\`--update') and creates HTML pages (\`--rebuild') for the current month."
            echo "You can create HTML pages for all historic data using \`--rebuild-all'."
            echo
            echo "Application options:"
            echo "      --[no-]update         [don't] update AWStats database"
            echo "      --[no-]rebuild        [don't] generate static HTML pages"
            echo "                              (current month only)"
            echo "  -a, --rebuild-all         generate static HTML pages (all historic data)"
            echo "  -o, --overwrite           re-create existing HTML pages (with --rebuild-all)"
            echo "      --no-config[=CONFIG]  don't skip domains without a config; use CONFIG,"
            echo "                              otherwise use default config (with --rebuild-all)"
            echo "      --format=FORMAT       output HTML pages according to FORMAT: plain, or"
            echo "                              gzip.  You also pass both comma separated."
            echo "                              default: plain"
            echo "      --lang=LANG           output HTML pages using language LANG."
            echo "                              default: en"
            echo "      --data-dir=PATH       path to AWStats data directory."
            echo "                              default: /var/lib/awstats"
            echo "      --www-dir=PATH        path to AWStats www directory."
            echo "                              default: /var/cache/awstats/www"
            echo "      --standalone=PATH     path to a standalone \`awstats.pl'"
            echo "  -v, --verbose             increase verbosity"
            echo "  -q, --quiet               decrease verbosity"
            echo
            echo "Help options:"
            echo "  -h, --help                display this help and exit"
            echo "      --version             output version information and exit"
            echo
            echo "Please report bugs using GitHub <https://github.com/PhrozenByte/awstats-update>"
            exit 0
            ;;

        "--version")
            echo "awstats-update $VERSION ($BUILD)"
            echo "Copyright (C) 2011-2016 Daniel Rudolf"
            echo "License GPLv3: GNU GPL version 3 only <http://gnu.org/licenses/gpl.html>."
            echo "This is free software: you are free to change and redistribute it."
            echo "There is NO WARRANTY, to the extent permitted by law."
            echo
            echo "Written by Daniel Rudolf <http://www.daniel-rudolf.de/>"
            exit 0
            ;;

        "--")
            shift
            break
            ;;

        default)
            echo "$APP_NAME: execution of getopt failed" >&2
            showUsage
            exit 1
            ;;
    esac
done

if [ -n "$STANDALONE" ]; then
    AWSTATS="$STANDALONE"
    [ "${AWSTATS:0:1}" == "/" ] || AWSTATS="$PWD/$AWSTATS"

    CONFIG_DIR="$(dirname "$AWSTATS")"
    [ -z "$AWSTATS_DATA_DIR" ] && AWSTATS_DATA_DIR="$CONFIG_DIR/data"
    [ -z "$AWSTATS_WWW_DIR" ] && AWSTATS_WWW_DIR="$CONFIG_DIR/www"
else
    AWSTATS="$(which "awstats")"
    CONFIG_DIR="/etc/awstats"
    [ -z "$AWSTATS_DATA_DIR" ] && AWSTATS_DATA_DIR="/var/lib/awstats"
    [ -z "$AWSTATS_WWW_DIR" ] && AWSTATS_WWW_DIR="/var/cache/awstats/www"
fi

# check AWStats executable
if [ -z "$AWSTATS" ]; then
    echo "$APP_NAME: AWStats executable not found" >&2
    exit 1
elif [ ! -e "$AWSTATS" ]; then
    echo "$APP_NAME: Invalid AWStats executable \`$AWSTATS': No such file or directory" >&2
    exit 1
elif [ ! -f "$AWSTATS" ] || [ ! -x "$AWSTATS" ]; then
    echo "$APP_NAME: Invalid AWStats executable \`$AWSTATS': Not an executable" >&2
    exit 1
fi

# nothing to do?
if [ "$UPDATE" == "no" ] && [ "$REBUILD" == "no" ]; then
    echo "$APP_NAME: You specified \`--no-update' and \`--no-rebuild'; do you really want to do nothing?" >&2
    exit 0
fi
if [ -z "$AWSTATS_FORMAT" ] && [ "$REBUILD" != "no" ]; then
    echo "$APP_NAME: You specified \'--rebuild' or \'--rebuild-all', but no output format; use \`--format'" >&2
    exit 1
fi

# validate --data-dir
[ "${AWSTATS_DATA_DIR:0:1}" == "/" ] || AWSTATS_DATA_DIR="$PWD/$AWSTATS_DATA_DIR"
if [ ! -e "$AWSTATS_DATA_DIR" ]; then
    echo "$APP_NAME: Invalid \`--data-dir': $AWSTATS_DATA_DIR: No such file or directory" >&2
    exit 1
elif [ ! -d "$AWSTATS_DATA_DIR" ]; then
    echo "$APP_NAME: Invalid \`--data-dir': $AWSTATS_DATA_DIR: Not a directory" >&2
    exit 1
fi

# validate --www-dir
[ "${AWSTATS_WWW_DIR:0:1}" == "/" ] || AWSTATS_WWW_DIR="$PWD/$AWSTATS_WWW_DIR"
if [ ! -e "$AWSTATS_WWW_DIR" ]; then
    echo "$APP_NAME: Invalid \`--www-dir': $AWSTATS_WWW_DIR: No such file or directory" >&2
    exit 1
elif [ ! -d "$AWSTATS_WWW_DIR" ]; then
    echo "$APP_NAME: Invalid \`--www-dir': $AWSTATS_WWW_DIR: Not a directory" >&2
    exit 1
fi

# resolve CONFIG
function resolveConfig() {
    local __NO_CONFIG_PARAM="--no-config"
    [ "$1" == "--no-config" ] && shift || __NO_CONFIG_PARAM=""

    local __RESULTVAR="$1"
    shift

    local __RETURN=0
    eval "$__RESULTVAR=\"\""
    while [ $# -gt 0 ]; do
        # step 1: check for a config path
        __DATA="$(resolveConfigPath --soft-fail "$1")"
        __EXIT_CODE=$?

        if [ "$__EXIT_CODE" -ne 0 ]; then
            if [ "$__EXIT_CODE" -eq 3 ]; then
                # step 2: check for a config spec
                __DATA="$(resolveConfigSpec --soft-fail $__NO_CONFIG_PARAM "$1")"
                __EXIT_CODE=$?

                if [ "$__EXIT_CODE" -ne 0 ]; then
                    [ "$__EXIT_CODE" -eq 3 ] && echo "$APP_NAME: Invalid parameter \`$1': No such config" >&2
                    __RETURN=1
                    shift
                    continue
                fi
            else
                __RETURN=1
                shift
                continue
            fi
        fi

        eval "$__RESULTVAR=\"\$(echo \"\$$__RESULTVAR\" ; echo \"\$__DATA\")\""
        shift
    done

    # result format: HOST_TYPE/HOST, /HOST or /
    eval "$__RESULTVAR=\"\$(echo \"\$$__RESULTVAR\" | LC_ALL=C sort -u)\""
    return $__RETURN
}

function resolveConfigPath() {
    local SOFT_FAIL="yes"
    [ "$1" == "--soft-fail" ] && shift || SOFT_FAIL="no"

    local CHECK_FILE="$1"
    local CHECK_FILENAME="$(basename "$1")"

    local FILE=""
    local FILENAME=""
    if [ -z "$CHECK_FILE" ] || [ "$CHECK_FILE" == "[default]" ]; then
        # default config file
        FILE="$CONFIG_DIR/awstats.conf"
        FILENAME="awstats.conf"
    elif [ "$CHECK_FILE" == "$CHECK_FILENAME" ]; then
        # filename
        if [ "$CHECK_FILENAME" == "awstats.conf" ] || [[ "$CHECK_FILENAME" =~ ^awstats\.(.+)\.conf$ ]]; then
            FILE="$CONFIG_DIR/$CHECK_FILENAME"
            FILENAME="$CHECK_FILENAME"
        fi
    elif [ "$CHECK_FILENAME" == "awstats.conf" ] || [[ "$CHECK_FILENAME" =~ ^awstats\.(.+)\.conf$ ]]; then
        # absolute/relative path
        FILE="$CONFIG_DIR/$CHECK_FILENAME"
        FILENAME="$CHECK_FILENAME"

        # get real directory of config file
        local CHECK_DIR="$(dirname "$CHECK_FILE")"
        [ "${CHECK_DIR:0:1}" != "/" ] && CHECK_DIR="$CONFIG_DIR/$CHECK_DIR"

        CHECK_DIR="$(readlink -f "$CHECK_DIR")"
        if [ -z "$CHECK_DIR" ]; then
            # readlink wasn't able to resolve the path (the path doesn't exist)
            echo "$APP_NAME: Invalid config path \`$CHECK_FILE': Unable to resolve path" >&2
            return 1
        fi

        # file must be in $CONFIG_DIR (can be a symlink)
        # we explicitly don't support any other config dirs,
        # awstats handling of them is unbelievable stupid...
        # if $CONFIG_DIR/awstats.conf exists, it's impossible
        # to use any other directory... wtf?
        local VALID_DIR="$(readlink -f "$CONFIG_DIR")"
        if [ "$CHECK_DIR" != "$VALID_DIR" ]; then
            echo "$APP_NAME: Invalid config path \`$CHECK_FILE': Config file must be in \`$CONFIG_DIR'" >&2
            return 1
        fi
    fi

    # invalid file; maybe it's a config spec?
    if [ -z "$FILE" ]; then
        [ "$SOFT_FAIL" == "yes" ] || echo "$APP_NAME: Invalid config path \`$CHECK_FILE'" >&2
        return 3
    fi

    # check file
    if [ ! -e "$FILE" ]; then
        echo "$APP_NAME: Invalid config path \`$CHECK_FILE': Resolved to invalid path \`$FILE': No such file or directory" >&2
        return 2
    elif [ ! -f "$FILE" ]; then
        echo "$APP_NAME: Invalid config path \`$CHECK_FILE': Resolved to invalid path \`$FILE': Not a file" >&2
        return 1
    fi

    if [[ "$FILENAME" =~ ^awstats\.(([^\.]+)\.)?(.+)\.conf$ ]]; then
        echo "${BASH_REMATCH[2]}/${BASH_REMATCH[3]}"
    else
        echo "/"
    fi
    return 0
}

function resolveConfigSpec() {
    local SOFT_FAIL="no"
    local SINGLE_MATCH="no"
    local NO_CONFIG_MATCH="no"
    while [ $# -gt 1 ]; do
        if [ "$1" == "--soft-fail" ]; then
            SOFT_FAIL="yes"
        elif [ "$1" == "--single" ]; then
            SINGLE_MATCH="yes"
        elif [ "$1" == "--no-config" ]; then
            NO_CONFIG_MATCH="yes"
        fi
        shift
    done

    local SPEC="$1"
    if ! [[ "$SPEC" =~ ^(([^\./]*)/)?([^/]*)$ ]]; then
        [ "$SOFT_FAIL" == "yes" ] || echo "$APP_NAME: Invalid config spec \`$SPEC'" >&2
        return 3
    fi

    local HOST_TYPE=""
    local HOST=""

    local CONFIG_FILE=""
    local CONFIG_NAME=""
    if [ "$SPEC" == "/" ]; then
        # default config file
        CONFIG_FILE="$CONFIG_DIR/awstats.conf"
    else
        # split HOST_TYPE and HOST
        [[ "$SPEC" == */* ]] && HOST_TYPE="$(echo "$SPEC" | cut -d '/' -f 1)" || HOST_TYPE="*"
        HOST="$(echo "$SPEC" | cut -d '/' -f 2)"

        # HOST_TYPE given, but HOST is empty - invalid input
        if [ -z "$HOST" ]; then
            echo "$APP_NAME: Invalid config spec \`$SPEC'" >&2
            return 1
        fi

        # prepare CONFIG_NAME
        [ -n "$HOST_TYPE" ] && local CONFIG_NAME=".$HOST_TYPE.$HOST" || local CONFIG_NAME=".$HOST"

        if [[ "$HOST_TYPE" != *\** ]] && [[ "$HOST" != *\** ]]; then
            # no wildcards, should match a single file
            CONFIG_FILE="$CONFIG_DIR/awstats$CONFIG_NAME.conf"
        else
            # resolve wildcards, probably multiple files
            [ -n "$HOST_TYPE" ] && HOST_TYPE_REGEX="\($(echo "$HOST_TYPE" | sed -e 's/[]\/$*.^|[]/\\&/g' -e 's/\\\*/[^\\.]*/g' -e 's/?/[^\\.]/g')\)\." || HOST_TYPE_REGEX="\(\)"
            local HOST_REGEX="\($(echo "$HOST" | sed -e 's/[]\/$*.^|[]/\\&/g' -e 's/\\\*/.*/g' -e 's/?/./g')\)\."

            local CONFIGS="$(
                (
                    find "$CONFIG_DIR" -mindepth 1 -maxdepth 1 -type f -name "awstats$CONFIG_NAME.conf" -printf '%f\n'
                    [ "$NO_CONFIG_MATCH" == "yes" ] && find "$AWSTATS_DATA_DIR" -mindepth 1 -maxdepth 1 -name "awstats??????$CONFIG_NAME.txt" -printf '%f\n'
                ) | sed -n -e "s/^awstats\.${HOST_TYPE_REGEX}${HOST_REGEX}conf$/\1\/\2/p" \
                           -e "s/^awstats[0-9]\{6\}\.${HOST_TYPE_REGEX}${HOST_REGEX}txt$/\1\/\2/p" \
                  | LC_ALL=C sort -u
            )"

            if [ -z "$CONFIGS" ]; then
                echo "$APP_NAME: Invalid config spec \`$SPEC': No matching config files found" >&2
                return 2
            elif [ "$SINGLE_MATCH" == "yes" ] && [ "$(echo "$CONFIGS" | wc -l)" -gt 1 ]; then
                echo "$APP_NAME: Invalid config spec \`$SPEC': Matches multiple config files" >&2
                return 1
            fi

            # return multiple files
            # no need for further checks, find already returns existing files only
            echo "$CONFIGS"
            return 0
        fi
    fi

    # check single file
    if [ ! -e "$CONFIG_FILE" ]; then
        if [ "$NO_CONFIG_MATCH" == "no" ] || [ -z "$(find "$AWSTATS_DATA_DIR" -mindepth 1 -maxdepth 1 -name "awstats??????$CONFIG_NAME.txt" -printf "." -quit)" ]; then
            echo "$APP_NAME: Invalid config spec \`$SPEC': Resolved to invalid path \`$CONFIG_FILE': No such file or directory" >&2
            return 2
        fi
    elif [ ! -f "$CONFIG_FILE" ]; then
        echo "$APP_NAME: Invalid config spec \`$SPEC': Resolved to invalid path \`$CONFIG_FILE': Not a file" >&2
        return 1
    fi

    echo "$HOST_TYPE/$HOST"
    return 0
}

# validate and resolve --no-config
# nearly the same as resolveConfig(), but with a preliminary check for arbitrary existing files
if [ -n "$NO_CONFIG" ]; then
    [ "${NO_CONFIG:0:1}" == "/" ] && NO_CONFIG_FILE="$NO_CONFIG" || NO_CONFIG_FILE="$CONFIG_DIR/$NO_CONFIG"
    if [ -e "$NO_CONFIG_FILE" ]; then
        # step 1: any existing file is sufficient
        if [ ! -f "$NO_CONFIG_FILE" ]; then
            echo "$APP_NAME: Invalid --no-config spec \`$NO_CONFIG': Resolved to invalid path \`$NO_CONFIG_FILE': Not a file" >&2
            exit 1
        fi
    else
        # step 2: check for a config path
        NO_CONFIG_DATA="$(resolveConfigPath --soft-fail "$NO_CONFIG")"
        NO_CONFIG_RESULT=$?

        if [ "$NO_CONFIG_RESULT" -ne 0 ]; then
            if [ "$NO_CONFIG_RESULT" -eq 3 ]; then
                # step 3: check for a config spec
                NO_CONFIG_DATA="$(resolveConfigSpec --soft-fail --single "$NO_CONFIG")"
                NO_CONFIG_RESULT=$?

                if [ "$NO_CONFIG_RESULT" -ne 0 ]; then
                    [ "$NO_CONFIG_RESULT" -eq 3 ] || echo "$APP_NAME: Invalid --no-config spec \`$NO_CONFIG'" >&2
                    exit 1
                fi
            else
                exit 1
            fi
        fi

        if [ "$NO_CONFIG_DATA" == "/" ]; then
            NO_CONFIG="$CONFIG_DIR/awstats.conf"
        elif [ "${NO_CONFIG_DATA:0:1}" == "/" ]; then
            NO_CONFIG="$CONFIG_DIR/awstats.$(echo "$NO_CONFIG_DATA" | cut -d '/' -f 2).conf"
        else
            NO_CONFIG="$CONFIG_DIR/awstats.$(echo "$NO_CONFIG_DATA" | cut -d '/' -f 1).$(echo "$NO_CONFIG_DATA" | cut -d '/' -f 2).conf"
        fi
    fi
fi

# prepare fds according to verbosity
# verbosity -1: hide stdout and stderr
# verbosity 0: print stderr, hide stdout
[ "$VERBOSE" -le -1 ] && exec 2> /dev/null
[ "$VERBOSE" -le 0 ] && exec 1> /dev/null
[ "$VERBOSE" -gt 1 ] && exec 3>&1 || exec 3> /dev/null
[ "$VERBOSE" -gt 2 ] && exec 4>&1 || exec 4> /dev/null

# add wildcard parameter if no parameters were supplied
[ $# -eq 0 ] && eval set -- "'*'"

# perform --update
if [ "$UPDATE" == "yes" ]; then
    echo "Performing update..."

    resolveConfig UPDATE_CONFIGS "$@"

    IFS=$'\n'; for CONFIG in $UPDATE_CONFIGS; do
        HOST_TYPE="$(echo "$CONFIG" | cut -d '/' -f 1)"
        HOST="$(echo "$CONFIG" | cut -d '/' -f 2)"

        if [ -n "$HOST_TYPE" ]; then
            IDENT="$HOST ($HOST_TYPE)"
            CONFIG_NAME="$HOST_TYPE.$HOST"
        elif [ -n "$HOST" ]; then
            IDENT="$HOST"
            CONFIG_NAME="$HOST"
        else
            IDENT="[default]"
            CONFIG_NAME="awstats.conf"
        fi

        echo "  - $IDENT"
        if [ -n "$AWSTATS_NICE" ]; then
            nice -n "$AWSTATS_NICE" \
                "$AWSTATS" -config="$CONFIG_NAME" -update \
                    | sed -e 's/^ /  /' | sed -e 's/^/    /' >&4
            UPDATE_EXIT_CODE=$?
        else
            "$AWSTATS" -config="$CONFIG_NAME" -update \
                | sed -e 's/^ /  /' | sed -e 's/^/    /' >&4
            UPDATE_EXIT_CODE=$?
        fi

        if [ "$UPDATE_EXIT_CODE" -ne 0 ]; then
            echo "  ! $IDENT FAILED with exit code $UPDATE_EXIT_CODE"
            EXIT_CODE=1
        fi
    done
fi

# check exit code
if [ "$EXIT_CODE" -ne 0 ]; then
    exit "$EXIT_CODE"
fi

# perform --rebuild
if [ "$REBUILD" == "current" ]; then
    echo "Collecting rebuild data..."

    resolveConfig REBUILD_CONFIGS "$@"

    REBUILD_DATA=""
    IFS=$'\n'; for CONFIG in $REBUILD_CONFIGS; do
        HOST_TYPE="$(echo "$CONFIG" | cut -d '/' -f 1)"
        HOST="$(echo "$CONFIG" | cut -d '/' -f 2)"

        # the config for this month doesn't exist yet
        # maybe we're at the beginning of a new month... rebuild the previous month
        # if there is no previous month yet, it will be automatically skipped
        if [ -n "$HOST_TYPE" ]; then
            CONFIG_WWW_DIR="$HOST_TYPE/$HOST"
        elif [ -n "$HOST" ]; then
            CONFIG_WWW_DIR="[none]/$HOST"
        else
            CONFIG_WWW_DIR="[none]/[default]"
        fi
        if [ ! -e "$AWSTATS_WWW_DIR/$CONFIG_WWW_DIR/$(date +%Y)/$(date +%m)" ]; then
            YEAR="$(date +%Y)"
            MONTH="$(date +%-m)"

            ((MONTH--))
            [ "${#MONTH}" -eq 1 ] && MONTH="0$MONTH"

            if [ "$MONTH" == "00" ]; then
                MONTH=12
                ((YEAR--))
            fi

            REBUILD_DATA="$(echo "$REBUILD_DATA" ; echo "$HOST_TYPE/$HOST/$YEAR/$MONTH")"
        fi

        # add current month
        REBUILD_DATA="$(echo "$REBUILD_DATA" ; echo "$HOST_TYPE/$HOST/$(date +%Y)/$(date +%m)")"

        # add year sum
        REBUILD_DATA="$(echo "$REBUILD_DATA" ; echo "$HOST_TYPE/$HOST/$(date +%Y)/all")"
    done

    # --rebuild implies --overwrite
    OVERWRITE="yes"

# perform --rebuild-all
elif [ "$REBUILD" == "all" ]; then
    function createTempConfig() {
        if [ $# -eq 2 ]; then
            local FILE="$CONFIG_DIR/awstats.$1.$2.conf"
            local DOMAIN="$2"
            local DOMAIN_ALIASES="$2 www.$2"
        elif [ $# -eq 1 ]; then
            local FILE="$CONFIG_DIR/awstats.$1.conf"
            local DOMAIN="$1"
            local DOMAIN_ALIASES="$1 www.$1"
        else
            local FILE="$CONFIG_DIR/awstats.conf"
            local DOMAIN="localhost"
            local DOMAIN_ALIASES="localhost 127.0.0.1 ::1"
        fi

        if [ -e "$FILE" ]; then
            echo "$APP_NAME: Unable to create temp config file \`$FILE': File exists" >&2
            return 1
        fi

        if [ "$(readlink -f "$FILE")" == "$(readlink -f "$NO_CONFIG")" ]; then
            echo "$APP_NAME: Unable to create temp config file \`$FILE': Temp config file includes itself as --no-config file ($NO_CONFIG)" >&2
            return 1
        fi

        echo -n "" > $FILE
        echo "Include \"$NO_CONFIG\"" >> "$FILE"
        echo "LogFile=\"/dev/null\"" >> "$FILE"
        echo "SiteDomain=\"$DOMAIN\"" >> "$FILE"
        echo "HostAliases=\"$DOMAIN_ALIASES\"" >> "$FILE"

        CLEANUP_TEMP_CONFIG="$(echo "$CLEANUP_TEMP_CONFIG" ; echo "$FILE")"

        return 0
    }

    function cleanupTempConfig() {
        IFS=$'\n'; for FILE in $CLEANUP_TEMP_CONFIG; do
            rm -f "$FILE"
        done
        exit
    }
    CLEANUP_TEMP_CONFIG=""
    trap cleanupTempConfig INT TERM EXIT

    echo "Collecting rebuild data..."

    [ -n "$NO_CONFIG" ] && NO_CONFIG_PARAM="--no-config" || NO_CONFIG_PARAM=""
    resolveConfig $NO_CONFIG_PARAM REBUILD_CONFIGS "$@"

    REBUILD_DATA=""
    IFS=$'\n'; for CONFIG in $REBUILD_CONFIGS; do
        HOST_TYPE="$(echo "$CONFIG" | cut -d '/' -f 1)"
        HOST="$(echo "$CONFIG" | cut -d '/' -f 2)"

        if [ -n "$HOST_TYPE" ]; then
            DATA_PATTERN="awstats??????.$HOST_TYPE.$HOST.txt"
            [ ! -f "$CONFIG_DIR/awstats.$HOST_TYPE.$HOST.conf" ] && createTempConfig "$HOST_TYPE" "$HOST"
            [ $? -ne 0 ] && EXIT_CODE=1 && continue
        elif [ -n "$HOST" ]; then
            DATA_PATTERN="awstats??????.$HOST.txt"
            [ ! -f "$CONFIG_DIR/awstats.$HOST.conf" ] && createTempConfig "$HOST"
            [ $? -ne 0 ] && EXIT_CODE=1 && continue
        else
            DATA_PATTERN="awstats??????.txt"
            [ ! -f "$CONFIG_DIR/awstats.conf" ] && createTempConfig
            [ $? -ne 0 ] && EXIT_CODE=1 && continue
        fi

        DATA_EXISTS="no"
        while IFS="" read -r -u 4 -d $'\0' FILE; do
            FILENAME="$(basename "$FILE")"

            REGEX="^awstats([0-9]{2})([0-9]{4})(\.(.+))?\.txt$"
            if ! [[ "$FILENAME" =~ $REGEX ]]; then
                echo "$APP_NAME: Unable to collect rebuild data: Invalid database file \`$FILE'" >&2
                exit 1
            fi

            YEAR="$(echo "$FILENAME" | sed -r "s/$REGEX/\2/")"
            MONTH="$(echo "$FILENAME" | sed -r "s/$REGEX/\1/")"

            REBUILD_DATA="$(echo "$REBUILD_DATA" ; echo "$HOST_TYPE/$HOST/$YEAR/$MONTH")"
            DATA_EXISTS="yes"

            # add year sum
            echo "$REBUILD_DATA" | grep --fixed-strings --line-regexp -q "$HOST_TYPE/$HOST/$YEAR/all"
            [ $? -eq 0 ] || REBUILD_DATA="$(echo "$REBUILD_DATA" ; echo "$HOST_TYPE/$HOST/$YEAR/all")"
        done 4< <(find "$AWSTATS_DATA_DIR" -mindepth 1 -maxdepth 1 -name "$DATA_PATTERN" -print0)

        if [ "$DATA_EXISTS" == "no" ]; then
            # if no data files were found, add at least the current month
            # obviously no HTML page will be built, but the user gets a clue what's happening
            # hosts without a config file have at least a single data file, so they can't get to this point
            REBUILD_DATA="$(echo "$REBUILD_DATA" ; echo "$HOST_TYPE/$HOST/$(date +%Y)/$(date +%m)")"
        fi
    done

    # sort rebuild data
    REBUILD_DATA="$(echo "$REBUILD_DATA" | LC_ALL=C sort)"
fi

if [ "$REBUILD" != "no" ]; then
    # read AWStats pages from config
    declare -A CONFIG_FILES

    function getPages() {
        local __RESULTVAR="$1"
        local __FILE="$2"

        # evaluate config files
        local __INNER_RESULT=""
        readPageConfig __INNER_RESULT "$__FILE"
        [ $? -eq 0 ] || return 1

        # append default pages (= lowest severity)
        __INNER_RESULT+="alldomains=1\n"
        __INNER_RESULT+="allhosts=1\nlasthosts=1\nunknownip=1\n"
        __INNER_RESULT+="alllogins=0\nlastlogins=0\n"
        __INNER_RESULT+="allrobots=1\nlastrobots=1\n"
        __INNER_RESULT+="allemails=0\nlastemails=0\n"
        __INNER_RESULT+="allemailr=0\nlastemailr=0\n"
        __INNER_RESULT+="session=1\n"
        __INNER_RESULT+="urldetail=1\nurlentry=1\nurlexit=1\n"
        __INNER_RESULT+="downloads=1\n"
        __INNER_RESULT+="osdetail=1\nunknownos=1\n"
        __INNER_RESULT+="browserdetail=1\nunknownbrowser=1\n"
        __INNER_RESULT+="screensize=0\n"
        __INNER_RESULT+="refererse=1\nrefererpages=1\n"
        __INNER_RESULT+="keyphrases=1\n"
        __INNER_RESULT+="keywords=1\n"
        __INNER_RESULT+="errors404=1\n"

        # remove duplicates (keep the first row = keep last specified config)
        eval "$__RESULTVAR=\"\$(echo 'main=1' ; printf \"$__INNER_RESULT\" | LC_ALL=C sort -u -t '=' -k 1,1)\""

        # remove invisible pages
        eval "$__RESULTVAR=\"\$(echo \"\$$__RESULTVAR\" | sed -ne 's/^\(.*\)=1$/\1/p')\""
        return 0
    }

    function readPageConfig() {
        local __RESULTVAR="$1"
        local __FILE="$2"

        # don't evaluate the same config file multiple times...
        if [ -n "${CONFIG_FILES[$__FILE]+isset}" ]; then
            eval "$__RESULTVAR=\"${CONFIG_FILES[$__FILE]}\$$__RESULTVAR\"";
        else
            while IFS= read -r __LINE || [ -n "$__LINE" ]; do
                __LINE="${__LINE%%#*}"
                __LINE="${__LINE#"${__LINE%%[![:space:]]*}"}"
                __LINE="${__LINE%"${__LINE##*[![:space:]]}"}"

                # skip empty lines
                [ -n "$__LINE" ] || continue

                # perform includes
                if [[ "$__LINE" =~ ^Include\ \"([^\"]+)\"$ ]] || [[ "$__LINE" =~ ^#include\ \"[^\"]+\"$ ]]; then
                    local INCLUDE="${BASH_REMATCH[1]}"
                    [ "${INCLUDE:0:1}" != "/" ] && INCLUDE="$(dirname "$__FILE")/$INCLUDE"

                    ((INCLUDE_DEPTH++))
                    if [ "$INCLUDE_DEPTH" -gt 100 ]; then
                        echo "$APP_NAME: Reached maximum include depth in config file \`$__FILE' (infinite loop?)" >&2
                        return 1
                    fi

                    readPageConfig "$__RESULTVAR" "$INCLUDE"
                    [ $? -eq 0 ] || return 1

                    ((INCLUDE_DEPTH--))
                    continue
                fi

                # get parameter
                # no need to validate the line, we're matching known configs only anyway
                local __PARAM="$(echo "$__LINE" | cut -d '=' -f 1)"
                __PARAM="${__PARAM%"${__PARAM##*[![:space:]]}"}"

                # get value
                local __VALUE="$(echo "$__LINE" | cut -d '=' -f 2 -s)"
                __VALUE="${__VALUE#"${__VALUE%%[![:space:]]*}"}"

                [[ "$__VALUE" == *\; ]] && __VALUE="${__VALUE:0: -1}"
                if [[ "$__VALUE" == \"*\" ]] || [[ "$__VALUE" == \'*\' ]]; then __VALUE="${__VALUE:1: -1}"; fi

                # replace __ENV__
                while [[ "$__VALUE" =~ __([^[:space:]_]+(_[^[:space:]_]+)*)__ ]]; do
                    local __ENV_NAME="__${BASH_REMATCH[1]}__"
                    local __ENV_VALUE="$(eval "echo \"\$${BASH_REMATCH[1]}\"")"
                    __VALUE="${__VALUE//${__ENV_NAME}/$__ENV_VALUE}"
                done

                # require value = < 0 | 1 >
                if [ -n "$__VALUE" ] && [ "$__VALUE" != "0" ]; then __VALUE="1"; else __VALUE="0"; fi

                # search for known configs...
                if [ "$__PARAM" == "ShowDomainsStats" ]; then         eval "$__RESULTVAR=\"alldomains=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowHostsStats" ]; then           eval "$__RESULTVAR=\"allhosts=$__VALUE\nlasthosts=$__VALUE\nunknownip=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowAuthenticatedUsers" ]; then   eval "$__RESULTVAR=\"alllogins=$__VALUE\nlastlogins=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowRobotsStats" ]; then          eval "$__RESULTVAR=\"allrobots=$__VALUE\nlastrobots=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowEMailSenders" ]; then         eval "$__RESULTVAR=\"allemails=$__VALUE\nlastemails=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowEMailReceivers" ]; then       eval "$__RESULTVAR=\"allemailr=__$__VALUE\nlastemailr=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowSessionsStats" ]; then        eval "$__RESULTVAR=\"session=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowPagesStats" ]; then           eval "$__RESULTVAR=\"urldetail=$__VALUE\nurlentry=$__VALUE\nurlexit=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowDownloadsStats" ]; then       eval "$__RESULTVAR=\"downloads=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowOSStats" ]; then              eval "$__RESULTVAR=\"osdetail=$__VALUE\nunknownos=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowBrowsersStats" ]; then        eval "$__RESULTVAR=\"browserdetail=$__VALUE\nunknownbrowser=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowScreenSizeStats" ]; then      eval "$__RESULTVAR=\"screensize=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowOriginStats" ]; then          eval "$__RESULTVAR=\"refererse=$__VALUE\nrefererpages=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowKeyphrasesStats" ]; then      eval "$__RESULTVAR=\"keyphrases=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowKeywordsStats" ]; then        eval "$__RESULTVAR=\"keywords=$__VALUE\n\$$__RESULTVAR\""; fi
                if [ "$__PARAM" == "ShowHTTPErrorsStats" ]; then      eval "$__RESULTVAR=\"errors404=$__VALUE\n\$$__RESULTVAR\""; fi
                # no distinct pages for ShowWormsStats, ShowFileTypesStats, ShowMiscStats, ShowHTTPErrorsStats, ShowSMTPErrorsStats, ShowClusterStats
                # ShowFileSizesStats is "not yet available" as of AWStats 7.2

                if [ "$__PARAM" == "LoadPlugin" ] && [[ "$__VALUE" == geoip* ]]; then   eval "$__RESULTVAR=\"plugin_$(echo "$__VALUE" | cut -d ' ' -f 1)=1\n\$$__RESULTVAR\""; fi
                if [[ "$__PARAM" =~ ^ExtraSectionName([0-9]+)$ ]]; then                 eval "$__RESULTVAR=\"allextra${BASH_REMATCH[1]}=1\n\$$__RESULTVAR\""; fi
            done < "$__FILE"

            # remember result
            eval "CONFIG_FILES[\$__FILE]=\"\$$__RESULTVAR\""
        fi

        return 0
    }

    # perform rebuild...
    echo "Generating static HTML pages..."

    REBUILD_EXIT_CODE=0
    REBUILD_GZIP_EXIT_CODE=0
    PREVIOUS_IDENT=""
    PREVIOUS_HOST_TYPE=""
    PREVIOUS_HOST=""
    IGNORE_HOST_TYPE=""
    IGNORE_HOST=""
    IFS=$'\n'; for DATA in $REBUILD_DATA; do
        HOST_TYPE="$(echo "$DATA" | cut -d '/' -f 1)"
        HOST="$(echo "$DATA" | cut -d '/' -f 2)"

        YEAR="$(echo "$DATA" | cut -d '/' -f 3)"
        MONTH="$(echo "$DATA" | cut -d '/' -f 4)"

        if [ -n "$HOST_TYPE" ]; then
            IDENT="$HOST ($HOST_TYPE)"
            CONFIG_NAME="$HOST_TYPE.$HOST"
            CONFIG_FILE="$CONFIG_DIR/awstats.$HOST_TYPE.$HOST.conf"
            DATA_FILE="$AWSTATS_DATA_DIR/awstats$([ "$MONTH" != "all" ] && echo "$MONTH" || echo "??")$YEAR.$HOST_TYPE.$HOST.txt"
        elif [ -n "$HOST" ]; then
            IDENT="$HOST"
            CONFIG_NAME="$HOST"
            CONFIG_FILE="$CONFIG_DIR/awstats.$HOST.conf"
            DATA_FILE="$AWSTATS_DATA_DIR/awstats$([ "$MONTH" != "all" ] && echo "$MONTH" || echo "??")$YEAR.$HOST.txt"

            HOST_TYPE="[none]"
        else
            IDENT="[default]"
            CONFIG_NAME="awstats.conf"
            CONFIG_FILE="$CONFIG_DIR/awstats.conf"
            DATA_FILE="$AWSTATS_DATA_DIR/awstats$([ "$MONTH" != "all" ] && echo "$MONTH" || echo "??")$YEAR.txt"

            HOST_TYPE="[none]"
            HOST="[default]"
        fi

        # something is wrong with this host; ignore it!
        [ "$IGNORE_HOST_TYPE" == "$HOST_TYPE" ] && [ "$IGNORE_HOST" == "$HOST" ] && continue

        # new host
        if [ "$PREVIOUS_HOST_TYPE" != "$HOST_TYPE" ] || [ "$PREVIOUS_HOST" != "$HOST" ]; then
            if [ -n "$PREVIOUS_HOST" ] && [ "$VERBOSE" -eq 2 ]; then
                if [ "$PREVIOUS_HOST_TYPE" != "$IGNORE_HOST_TYPE" ] || [ "$PREVIOUS_HOST" != "$IGNORE_HOST" ]; then
                    echo "" >&3
                fi
            fi

            if [ "$REBUILD_EXIT_CODE" -ne 0 ]; then
                echo "  ! $PREVIOUS_IDENT FAILED"
            elif [ "$REBUILD_GZIP_EXIT_CODE" -ne 0 ]; then
                echo "  ~ $PREVIOUS_IDENT COMPRESSION FAILED"
            fi
            REBUILD_EXIT_CODE=0
            REBUILD_GZIP_EXIT_CODE=0

            PREVIOUS_IDENT="$IDENT"
            PREVIOUS_HOST_TYPE="$HOST_TYPE"
            PREVIOUS_HOST="$HOST"

            # check for AWStats config file
            if [ ! -f "$CONFIG_FILE" ]; then
                echo "  - $IDENT: config file not found; skipping..."
                IGNORE_HOST_TYPE="$HOST_TYPE"
                IGNORE_HOST="$HOST"
                continue
            fi

            # read pages from config
            getPages PAGES "$CONFIG_FILE"
            if [ $? -ne 0 ]; then
                echo "  - $IDENT: unable to read pages from config file; skipping..."
                IGNORE_HOST_TYPE="$HOST_TYPE"
                IGNORE_HOST="$HOST"
                continue
            fi

            # print current host
            if [ "$VERBOSE" -eq 2 ]; then
                echo -n "  - $IDENT: " >&3
            else
                echo "  - $IDENT"
            fi
        fi

        # check for AWStats data file
        if [ "$MONTH" != "all" ]; then
            if [ ! -f "$DATA_FILE" ]; then
                echo "    - $YEAR-$MONTH: no data; skipping..." >&4
                [ "$VERBOSE" -eq 2 ] && echo -n "$YEAR-$MONTH [no data] " >&3
                continue
            fi
        elif [ -z "$(find "$(dirname "$DATA_FILE")" -maxdepth 1 -name "$(basename "$DATA_FILE")" -print -quit)" ]; then
            echo "    - $YEAR-$MONTH: no data; skipping..." >&4
            [ "$VERBOSE" -eq 2 ] && echo -n "$YEAR-$MONTH [no data] " >&3
            continue
        fi

        # create directories, if necessary
        [ -d "$AWSTATS_WWW_DIR/$HOST_TYPE" ] || mkdir "$AWSTATS_WWW_DIR/$HOST_TYPE"
        [ -d "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST" ] || mkdir "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST"
        [ -d "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR" ] || mkdir "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR"

        # delete and re-create destination directory (either --rebuild or --overwrite specified)
        if [ -e "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH" ]; then
            if [ "$OVERWRITE" == "yes" ]; then
                rm -r "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH"
            else
                echo -n "    ~ $YEAR-$MONTH: exists; skipping..." >&4
                [ "$VERBOSE" -eq 2 ] && echo -n "$YEAR-$MONTH [exists] " >&3
                continue
            fi
        fi
        mkdir "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH"

        # let the user know what happens
        echo -n "    - $YEAR-$MONTH: " >&4
        [ "$VERBOSE" -eq 2 ] && echo -n "$YEAR-$MONTH " >&3

        # generate static HTML pages
        ROUND_EXIT_CODE=0
        ROUND_GZIP_EXIT_CODE=0
        for PAGE in $PAGES; do
            echo -n "$PAGE " >&4

            if [ -n "$AWSTATS_NICE" ]; then
                nice -n "$AWSTATS_NICE" \
                    "$AWSTATS" -config="$CONFIG_NAME" \
                        -output="$PAGE" -year="$YEAR" -month="$MONTH" \
                        -staticlinks -lang="$AWSTATS_LANG" \
                    > "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html"
                PAGE_EXIT_CODE=$?
            else
                "$AWSTATS" -config="$CONFIG_NAME" \
                    -output="$PAGE" -year="$YEAR" -month="$MONTH" \
                    -staticlinks -lang="$AWSTATS_LANG" \
                > "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html"
                PAGE_EXIT_CODE=$?
            fi

            if [ "$PAGE_EXIT_CODE" -eq 0 ]; then
                # create compressed HTML page
                if [[ ",$AWSTATS_FORMAT," == *,gzip,* ]]; then
                    gzip -c "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html" \
                        > "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html.gz"
                    PAGE_GZIP_EXIT_CODE=$?

                    if [ "$PAGE_GZIP_EXIT_CODE" -ne 0 ]; then
                        # delete invalid compressed file
                        rm -f "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html.gz"

                        echo -n "[COMPRESSION FAILED with exit code $PAGE_GZIP_EXIT_CODE] " >&4
                        ROUND_GZIP_EXIT_CODE=1
                        REBUILD_GZIP_EXIT_CODE=1
                        EXIT_CODE=1

                        # pass compression error if gzip is the sole output format
                        if [[ ",$AWSTATS_FORMAT," != *,plain,* ]]; then
                            ROUND_EXIT_CODE=1
                            REBUILD_EXIT_CODE=1
                        fi
                    fi
                fi

                # remove plain HTML page
                if [[ ",$AWSTATS_FORMAT," != *,plain,* ]]; then
                    rm -f "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html"
                fi
            else
                # delete invalid page
                rm -f "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.$PAGE.html"

                echo -n "[FAILED with exit code $PAGE_EXIT_CODE] " >&4
                ROUND_EXIT_CODE=1
                REBUILD_EXIT_CODE=1
                EXIT_CODE=1
            fi
        done

        echo "" >&4
        if [ "$ROUND_EXIT_CODE" -eq 0 ]; then
            # symlink index.html
            if [[ ",$AWSTATS_FORMAT," == *,plain,* ]]; then
                ln -rs "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.main.html" "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/index.html"
            fi
            if [[ ",$AWSTATS_FORMAT," == *,gzip,* ]] && [ -f "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.main.html.gz" ]; then
                ln -rs "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/awstats.$HOST_TYPE.$HOST.main.html.gz" "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH/index.html.gz"
            fi

            # show compression errors only when the round didn't failed anyway
            if [ "$ROUND_GZIP_EXIT_CODE" -ne 0 ]; then
                echo "    ~ $YEAR-$MONTH COMPRESSION FAILED" >&4
                [ "$VERBOSE" -eq 2 ] && echo -n "[COMPRESSION FAILED] " >&3
            fi
        else
            # delete empty dir (no pages were built)
            [ -n "$(find "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH" -maxdepth 0 -empty)" ] && rmdir "$AWSTATS_WWW_DIR/$HOST_TYPE/$HOST/$YEAR/$MONTH"

            echo "    ! $YEAR-$MONTH FAILED" >&4
            [ "$VERBOSE" -eq 2 ] && echo -n "[FAILED] " >&3
        fi
    done

    [ -n "$PREVIOUS_HOST" ] && [ "$VERBOSE" -eq 2 ] && echo "" >&3
    if [ "$REBUILD_EXIT_CODE" -ne 0 ]; then
        echo "  ! $IDENT FAILED"
    elif [ "$REBUILD_GZIP_EXIT_CODE" -ne 0 ]; then
        echo "  ~ $IDENT COMPRESSION FAILED"
    fi
fi

# clean up
exec 3>&-
exec 4>&-

exit "$EXIT_CODE"
